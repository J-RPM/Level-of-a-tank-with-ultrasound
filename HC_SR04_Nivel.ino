/*
              Medidor de litros de un depósito, a partir de la distancia desde la parte superior al líquido
                             Distancia medida con sensor de ultrasonidos: HC-SR04
                                      Display OLED: SSD1306 (128x64)
                                   Aviso acústico al llegar a la reserva
                                 Envío de los datos por Bluetooth (HC-05) 
                                   
                                            *** IMPORTANTE ***
                La librería: Adafruit_SSD1306.h permite el uso de múltiples tamaños de pantalla 
            Comprueba que estén habilitos los códigos de tamaño y dirección I2C de esta pantalla OLED
                                        #define SSD1306_I2C_ADDRESS   0x3C
                                            #define SSD1306_128_64
__________________ _____________________________________________________________________________________________________
                                            Escrito por: J_RPM
                                     Más información: http://j-rpm.com/
                                         Noviembre de 2022 (v1.1)
__________________ _____________________________________________________________________________________________________
 */
 
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>       //https://github.com/adafruit/Adafruit-GFX-Library
#include <Adafruit_SSD1306.h>   //https://github.com/adafruit/Adafruit_SSD1306

// Dirección I2C del display OLED
#define OLED_ADDR   0x3c //
#define OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);

#define pinBeep 11           // Pin Buzzer
#define echoPin 12           // Pin Echo HC-SR04
#define trigPin 13           // Pin Trigger HC-SR04

String Version = "HC_SR04_Nivel (v1.1)"; 
boolean dir  = false;
int x = 0;

// Configuración del depósito
float D_max = 1400;            // Altura del sensor hasta el fondo del depósito en milímetros
float D_offset = 50;           // Distancia mínima del sensor hasta el líquido en milímetros (depósito lleno)
float Reserva  = 400;          // Milímetros de combustible mínimo, desde el fondo del depósito al nivel del líquido = Reserva                   
float L_max = 1000;            // Capacidad máxima del depósito, litros
float Litro_mm;                // Para calcular el número de litros por milímetro >>> L_max /(D_max - D_offset) 
int Repe;                      // Número de medidas de distancia consecutivas, para promediar el valor medido
int Retardo;                   // Microsegundos de retardo entre dos lecturas consecutivas

/*______________________________________________________________________________________________
                           >>>   Gráfico 128x64   <<<
  Para crear este código a partir de una imagen BMP, puedes utilizar el software: LCD Assistant
                    http://en.radzio.dxp.pl/bitmap_converter/
 */
static const unsigned char PROGMEM Cgraf_JR2 [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x30, 0xDF, 0xBE, 0x3E, 0x38, 0x1F, 0x1F, 0x7C, 0x7C, 0x73, 0x7E, 0x7C, 0x00, 0x00,
0x00, 0x00, 0x30, 0xC6, 0x33, 0x63, 0x64, 0x19, 0x98, 0x66, 0xC6, 0xCB, 0x18, 0xC6, 0x00, 0x00,
0x03, 0x06, 0x30, 0xC6, 0x33, 0x63, 0x60, 0x19, 0x98, 0x66, 0xC6, 0xC3, 0x18, 0xC6, 0x60, 0xC0,
0x0C, 0x18, 0x30, 0xC6, 0x3E, 0x63, 0x78, 0x19, 0x9F, 0x66, 0xC6, 0xF3, 0x18, 0xC6, 0x18, 0x30,
0x10, 0x20, 0x30, 0xC6, 0x36, 0x63, 0x3C, 0x19, 0x98, 0x7C, 0xC6, 0x7B, 0x18, 0xC6, 0x04, 0x08,
0x0C, 0x18, 0x30, 0xC6, 0x33, 0x63, 0x0C, 0x19, 0x98, 0x60, 0xC6, 0x1B, 0x18, 0xC6, 0x18, 0x30,
0x03, 0x06, 0x30, 0xC6, 0x33, 0x63, 0x4C, 0x19, 0x98, 0x60, 0xC6, 0x9B, 0x18, 0xC6, 0x60, 0xC0,
0x00, 0x00, 0x3E, 0xC6, 0x33, 0x3E, 0x38, 0x1F, 0x1F, 0x60, 0x7C, 0x73, 0x18, 0x7C, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xF8, 0xF8, 0xE0, 0xE0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xCC, 0xCC, 0xE0, 0xE0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xCC, 0xCC, 0xF1, 0xE0,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xCC, 0xCC, 0xD1, 0x60,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xF8, 0xCC, 0xDB, 0x60,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xD8, 0xF8, 0xDB, 0x60,
0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xCC, 0xC0, 0xCA, 0x60,
0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xCC, 0xC0, 0xCE, 0x60,
0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0xCC, 0xC0, 0xCE, 0x60,
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0xE0, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xE0, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0xE0, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x07, 0xE0, 0x00, 0x3E, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x03, 0xC0, 0x00, 0x7E, 0x04, 0x0F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xE0, 0x3F, 0x07, 0xE0, 0x00, 0xFE, 0x04, 0x0F, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0xF0, 0x3F, 0x07, 0xC0, 0x01, 0xF0, 0x08, 0x1F, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x0F, 0xF0, 0x7E, 0x07, 0xF0, 0x01, 0xF0, 0x08, 0x7F, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x1F, 0xF0, 0xF8, 0x0F, 0xFE, 0x03, 0xF0, 0x11, 0xFF, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x3F, 0xF1, 0xF0, 0x0F, 0xF4, 0x07, 0xF0, 0x13, 0xF8, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x7F, 0x03, 0xF8, 0x0F, 0xE3, 0x07, 0xF0, 0x23, 0xF0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xFE, 0x07, 0xF8, 0x0F, 0xE0, 0x87, 0xE0, 0x27, 0xF0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0xFE, 0x07, 0xF0, 0x0F, 0xC0, 0x63, 0xE0, 0x47, 0xF0, 0x00, 0x03, 0x80, 0x00,
0x00, 0x00, 0x01, 0xFE, 0x07, 0xF0, 0x0F, 0xC0, 0x17, 0xF0, 0x87, 0xE1, 0x80, 0x07, 0xC0, 0x00,
0x00, 0x00, 0x01, 0xFC, 0x07, 0xF0, 0x07, 0xC0, 0x03, 0xFC, 0x8F, 0xF0, 0x80, 0x07, 0xC1, 0x00,
0x00, 0x00, 0x03, 0xFC, 0x07, 0xFC, 0x07, 0xC0, 0x07, 0xEF, 0x0F, 0xF8, 0xE0, 0xFF, 0x81, 0xC0,
0x00, 0x0C, 0x03, 0xFC, 0x03, 0xFF, 0xC7, 0xE0, 0x07, 0xE3, 0x0F, 0xFF, 0xE1, 0xFF, 0x81, 0xE0,
0x00, 0x3E, 0x07, 0xFC, 0x03, 0xE7, 0xC7, 0xE0, 0x07, 0xE2, 0x0F, 0xF7, 0xF3, 0xFC, 0x01, 0xF0,
0x00, 0x7E, 0x07, 0xFC, 0x03, 0xF1, 0xC3, 0xE0, 0x03, 0xF2, 0x0F, 0x9F, 0xD3, 0xFC, 0x01, 0xF8,
0x01, 0xFF, 0x07, 0xFC, 0x03, 0xF1, 0x03, 0xF0, 0x03, 0xF4, 0x0F, 0xFE, 0x4B, 0xFC, 0xFB, 0xF0,
0x03, 0xFF, 0x03, 0xFC, 0x03, 0xF9, 0x03, 0xF0, 0x01, 0xF8, 0x07, 0xFC, 0x0F, 0xCF, 0xF8, 0xE0,
0x07, 0xFC, 0x03, 0xFC, 0x01, 0xFC, 0x03, 0xF0, 0x01, 0xF8, 0x07, 0xF0, 0x1F, 0xCF, 0x8C, 0xF8,
0x0F, 0xFC, 0x03, 0xFE, 0x01, 0xFC, 0x03, 0xF0, 0x01, 0xF8, 0x03, 0xF8, 0x0F, 0xFF, 0x81, 0xFC,
0x1F, 0xFC, 0x01, 0xFE, 0x01, 0xFE, 0x03, 0xF0, 0x01, 0xDC, 0x03, 0xF8, 0x0F, 0xFF, 0xCF, 0xFE,
0x3F, 0xFC, 0x01, 0xFE, 0x00, 0xFE, 0x07, 0x38, 0x01, 0xDC, 0x01, 0xFC, 0x0F, 0xFF, 0xFF, 0xF6,
0x3F, 0x1E, 0x00, 0xEE, 0x01, 0xEE, 0x07, 0x30, 0x07, 0xBC, 0x03, 0xDC, 0x0F, 0xFF, 0x9F, 0xFC,
0x3F, 0x1F, 0x01, 0xDC, 0x03, 0xEE, 0x07, 0x70, 0x07, 0x38, 0x0F, 0xB8, 0x0F, 0xFF, 0x02, 0x10,
0x1F, 0x9F, 0xC3, 0xDC, 0x07, 0x8E, 0x0E, 0x70, 0x0E, 0x38, 0x0E, 0x38, 0x01, 0x0E, 0x07, 0xF8,
0x1F, 0x8F, 0xE3, 0x9C, 0x07, 0x0E, 0x0E, 0x78, 0x0E, 0xB8, 0x0C, 0x30, 0x01, 0x1C, 0x07, 0xF0,
0x3D, 0x87, 0x63, 0x9C, 0x06, 0x0C, 0x0E, 0x30, 0x1F, 0x98, 0x18, 0x30, 0x00, 0xB8, 0x07, 0xF0,
0x79, 0x83, 0x33, 0x1C, 0x0C, 0x0C, 0x0C, 0x30, 0x1F, 0xD8, 0x30, 0x30, 0x01, 0xB8, 0x07, 0xD0,
0xE1, 0x81, 0x83, 0x0C, 0x1C, 0x0C, 0x0C, 0x38, 0x38, 0xF8, 0x70, 0x60, 0x0F, 0xFC, 0x07, 0xC0,
0x61, 0x81, 0x87, 0x8C, 0x1C, 0x0C, 0x0E, 0x38, 0x38, 0x38, 0x30, 0x60, 0x1F, 0xFC, 0x07, 0x00,
0x61, 0xC1, 0x9F, 0xFF, 0x06, 0x0F, 0x3F, 0xBC, 0x7E, 0x3E, 0x3C, 0x78, 0x18, 0xF8, 0x06, 0x00
};


//______________________________________________________________________________________________

//Comprueba que la librería Adafruit_SSD1306.h esté configurada para este tamaño de pantalla
#if (SSD1306_LCDHEIGHT != 64)
  #error("Display incorrecto, revisa: Adafruit_SSD1306.h");
#endif

void setup() {
  Serial.begin(38400);
  Serial.println(F("********************"));  
  Serial.println(Version);  
  Serial.println(F("********************"));  

  // Se calcula el número de repeticiones y el retardo, en función del tamaño del depósito
  Retardo = D_max * 2 * 2.9144 * 2;          // Microsegundos entre 2 lecturas consecutivas = Dos veces el tiempo del eco con el depósito vacío 
  Repe = 500 / (Retardo/1000);               // Repeticiones = 500 mSeg / Retardo(mSeg) 

  // Se calcula el número de litros por centímetro >>> L_max /(D_max - D_offset) 
  Litro_mm = L_max /(D_max - D_offset);              
  Serial.print(F("Litros del depósito lleno: "));  
  Serial.println(L_max);  
  Serial.print(F("Altura del sensor (mm): "));  
  Serial.println(D_max);  
  Serial.print(F("Distancia del sensor con el depósito lleno (mm): "));  
  Serial.println(D_offset);  
  Serial.print(F("Litros por milímetro: "));  
  Serial.println(Litro_mm);  
  Serial.print(F("Repeticiones: "));  
  Serial.println(Repe);  
  Serial.print(F("Retardo (uS): "));  
  Serial.println(Retardo);  
  
  pinMode(pinBeep,OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(trigPin, OUTPUT);
   
  //Inicializa I2C con dirección 0x3C (OLED 128x64)
  display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR);
  
  // Presenta el logo durante 2 segundos
  logo();
 
  // 5 destellos del logo invirtiendo, con avisos acústicos
  for(int i = 0; i < 5; i++){
    digitalWrite(pinBeep,HIGH);
    display.invertDisplay(true);
    delay (20);
    digitalWrite(pinBeep,LOW);
    display.invertDisplay(false);
    delay (50);
  }
  delay (500);
  display.clearDisplay();
}

void loop() {
  unsigned long tiempo, distancia, litros;
  unsigned long tiempo_n=0;
  
  // Tiempo medio despues de 'n' medidas
  for(int i = 0; i < Repe; i++){
    // Envía impulso
    digitalWrite(trigPin, LOW);  
    delayMicroseconds(5);          
    digitalWrite(trigPin, HIGH);
    delayMicroseconds(10); 
    digitalWrite(trigPin, LOW);
    
    // Mide el tiempo del eco recibido
    tiempo = pulseIn(echoPin, HIGH);
    
    // Limita la medida a la distancia máxima del depósito
    if (D_max <= (tiempo/2) / 2.9144) {
      i = Repe;
      tiempo = D_max * 2 * 2.9144;
      tiempo_n = tiempo * (Repe-1);
    }

    tiempo_n = tiempo_n + tiempo;
    delayMicroseconds(Retardo); 
  }
  tiempo = tiempo_n / Repe;
  Serial.print(F("Tiempo: "));  
  Serial.println(tiempo);  
  

  //Limita la medida máxima a la altura del depósito >>> tiempo = D_max * 2 * 2.9144
  if (tiempo <= (D_max * 2 * 2.9144)) {
    distancia = (tiempo/2) / 2.9144;    // Milímetros
  }else{
    distancia = D_max;                  // Distancia máxima = Depósito vacío
  }

  Serial.print(distancia);  
  Serial.println(F(" mm."));  

  // Calcula los litros del depósito, en función de la distancia desde el sensor hasta el líquido
  // litros = L_max - ((distancia - D_offset) * Litro_mm); 
  litros = L_max - ((distancia - D_offset) * Litro_mm);

  Serial.print(litros);  
  Serial.println(F(" L."));  

  //Mide el número de caracteres
  String largo =  String(litros, DEC); 
  
  //Alinea el número a la derecha 
  int puntoInicio = 72 - (18*(largo.length())-1);   

  //Display OLED
  display.setCursor(0,0);  
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.println  ("Almacenado");
  
  display.setCursor(puntoInicio,20);  
  display.setTextSize(3);
  display.println(litros);
  display.setCursor(74,20);
  display.setTextSize(3);
  display.println(" L.");

  efectoOnda();

  //Refresca el display
  display.display();
  pitaReserva(distancia);        //Pita al llegar a la reserva
  
  display.clearDisplay();
}

///////////////////////////////////////
//////////// Subrutinas ///////////////
///////////////////////////////////////

// Pita al llegar a la reserva
 void pitaReserva(int valor) {
    if(valor >= (D_max - Reserva)){  
        digitalWrite(pinBeep,HIGH);
        delay (100);
        digitalWrite(pinBeep,LOW);
        delay (100);
    }else{
        digitalWrite(pinBeep,LOW);
        delay (200);
    }
}
///////////////////////////////////////
void logo() {

  // Borra el display
  display.clearDisplay();
      
  // Carga y presenta el archivo BMP en el display
  display.drawBitmap(0, 0, Cgraf_JR2, 128, 64, 1);
  display.display();
  delay(2000);

 }
///////////////////////////////////////
void efectoOnda() {
  display.setTextSize(2);
  if(dir == false){
    x = x + 6;
    if(x >= 80){dir = true;}
    display.setCursor(x,50);  
    display.println(">>>");
  }else{
    x = x - 6;
    if(x <= 0){dir = false;}
    display.setCursor(x,50);  
    display.println("<<<");
  }
}
// FIN //  
